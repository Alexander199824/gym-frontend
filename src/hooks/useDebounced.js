// src/hooks/useDebounced.js
// FUNCI√ìN: Sistema de hooks con DEBOUNCING para evitar rate limiting
// PREVIENE: M√∫ltiples peticiones simult√°neas al backend

import { useState, useEffect, useCallback, useRef } from 'react';

// üö¶ COORDINADOR GLOBAL DE PETICIONES
class RequestCoordinator {
  constructor() {
    this.activeRequests = new Map(); // endpoint -> Promise
    this.requestQueue = []; // Array de {endpoint, requestFn, resolve, reject}
    this.processing = false;
    this.lastRequestTime = 0;
    this.minDelay = 200; // 200ms m√≠nimo entre peticiones
  }

  // Coordinar petici√≥n para evitar duplicados
  async coordinateRequest(endpoint, requestFn) {
    // Si ya hay una petici√≥n activa para este endpoint, reutilizar
    if (this.activeRequests.has(endpoint)) {
      console.log(`üîÑ Reutilizando petici√≥n activa: ${endpoint}`);
      return this.activeRequests.get(endpoint);
    }

    // Crear nueva petici√≥n
    const requestPromise = this.executeRequest(endpoint, requestFn);
    
    // Registrar petici√≥n activa
    this.activeRequests.set(endpoint, requestPromise);
    
    // Limpiar cuando termine
    requestPromise.finally(() => {
      this.activeRequests.delete(endpoint);
    });
    
    return requestPromise;
  }

  // Ejecutar petici√≥n con timing adecuado
  async executeRequest(endpoint, requestFn) {
    const now = Date.now();
    const timeSinceLastRequest = now - this.lastRequestTime;
    
    // Si es muy pronto, esperar
    if (timeSinceLastRequest < this.minDelay) {
      const delay = this.minDelay - timeSinceLastRequest;
      console.log(`‚è∞ Esperando ${delay}ms antes de hacer petici√≥n: ${endpoint}`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
    
    this.lastRequestTime = Date.now();
    
    try {
      const result = await requestFn();
      console.log(`‚úÖ Petici√≥n exitosa: ${endpoint}`);
      return result;
    } catch (error) {
      console.warn(`‚ö†Ô∏è Error en petici√≥n: ${endpoint}`, error.message);
      throw error;
    }
  }

  // Obtener estado actual
  getStatus() {
    return {
      activeRequests: this.activeRequests.size,
      queuedRequests: this.requestQueue.length,
      processing: this.processing
    };
  }
}

// Instancia global del coordinador
const requestCoordinator = new RequestCoordinator();

// üé£ HOOK PRINCIPAL CON DEBOUNCING
export const useDebounced = (endpoint, requestFn, options = {}) => {
  const {
    fallbackData = null,
    debounceMs = 300,
    retryCount = 2,
    retryDelay = 1000,
    cacheMs = 5 * 60 * 1000, // 5 minutos
    enabled = true,
    onSuccess = null,
    onError = null
  } = options;

  // Estados
  const [data, setData] = useState(fallbackData);
  const [isLoading, setIsLoading] = useState(false);
  const [isLoaded, setIsLoaded] = useState(false);
  const [error, setError] = useState(null);
  const [lastFetch, setLastFetch] = useState(null);

  // Referencias
  const debounceTimer = useRef(null);
  const retryTimer = useRef(null);
  const mountedRef = useRef(true);
  const currentRetry = useRef(0);

  // Funci√≥n de fetch con coordinaci√≥n
  const fetchData = useCallback(async (attempt = 1) => {
    if (!enabled || !requestFn) return;

    try {
      setIsLoading(true);
      setError(null);

      // Coordinar petici√≥n para evitar duplicados
      const result = await requestCoordinator.coordinateRequest(
        endpoint,
        requestFn
      );

      // Solo actualizar si el componente sigue montado
      if (mountedRef.current) {
        setData(result);
        setIsLoaded(true);
        setLastFetch(Date.now());
        currentRetry.current = 0;

        if (onSuccess) {
          onSuccess(result);
        }
      }

    } catch (error) {
      if (!mountedRef.current) return;

      console.warn(`‚ö†Ô∏è Error en useDebounced (${endpoint}):`, error.message);
      
      // Determinar si debemos reintentar
      const shouldRetry = attempt < retryCount && (
        error.response?.status === 429 || // Too Many Requests
        error.response?.status >= 500 || // Server Error
        error.code === 'ERR_NETWORK' || // Network Error
        error.code === 'ECONNABORTED' // Timeout
      );

      if (shouldRetry) {
        console.log(`üîÑ Reintentando ${endpoint} en ${retryDelay * attempt}ms... (${attempt}/${retryCount})`);
        retryTimer.current = setTimeout(() => {
          if (mountedRef.current) {
            fetchData(attempt + 1);
          }
        }, retryDelay * attempt);
      } else {
        // No reintentar m√°s, usar fallback
        setError(error);
        setData(fallbackData);
        setIsLoaded(true);
        currentRetry.current = 0;

        if (onError) {
          onError(error);
        }
      }
    } finally {
      if (mountedRef.current) {
        setIsLoading(false);
      }
    }
  }, [endpoint, requestFn, enabled, fallbackData, retryCount, retryDelay, onSuccess, onError]);

  // Funci√≥n de fetch con debounce
  const debouncedFetch = useCallback(() => {
    // Limpiar timer anterior
    if (debounceTimer.current) {
      clearTimeout(debounceTimer.current);
    }

    // Programar nueva petici√≥n
    debounceTimer.current = setTimeout(() => {
      fetchData(1);
    }, debounceMs);
  }, [fetchData, debounceMs]);

  // Funci√≥n de refetch manual
  const refetch = useCallback(() => {
    // Limpiar timers
    if (debounceTimer.current) {
      clearTimeout(debounceTimer.current);
    }
    if (retryTimer.current) {
      clearTimeout(retryTimer.current);
    }

    // Fetch inmediato
    fetchData(1);
  }, [fetchData]);

  // Verificar si necesita refresh
  const needsRefresh = useCallback(() => {
    if (!lastFetch || !cacheMs) return true;
    return Date.now() - lastFetch > cacheMs;
  }, [lastFetch, cacheMs]);

  // Efecto principal
  useEffect(() => {
    if (!enabled) return;

    // Solo fetch si no tenemos datos o el cache expir√≥
    if (!isLoaded || needsRefresh()) {
      debouncedFetch();
    }

    // Cleanup
    return () => {
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
      if (retryTimer.current) {
        clearTimeout(retryTimer.current);
      }
    };
  }, [enabled, isLoaded, needsRefresh, debouncedFetch]);

  // Cleanup al desmontar
  useEffect(() => {
    mountedRef.current = true;
    return () => {
      mountedRef.current = false;
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current);
      }
      if (retryTimer.current) {
        clearTimeout(retryTimer.current);
      }
    };
  }, []);

  return {
    data,
    isLoading,
    isLoaded,
    error,
    refetch,
    needsRefresh: needsRefresh(),
    lastFetch,
    retryCount: currentRetry.current
  };
};

// üé£ HOOK ESPEC√çFICO PARA GYM CONFIG
export const useGymConfigDebounced = () => {
  const fallback = {
    name: 'Elite Fitness',
    tagline: 'Tu transformaci√≥n comienza aqu√≠',
    description: 'El mejor gimnasio de Guatemala',
    contact: {
      phone: '+502 2234-5678',
      email: 'info@elitefitness.gt',
      address: 'Zona 10, Ciudad de Guatemala'
    },
    hours: {
      full: 'Lun-Vie 6:00-22:00, S√°b 8:00-20:00'
    },
    social: {
      facebook: { url: 'https://facebook.com/elitefitness', active: true },
      instagram: { url: 'https://instagram.com/elitefitness', active: true }
    }
  };

  return useDebounced(
    '/api/gym/config',
    () => import('../services/apiService').then(module => module.default.getGymConfig()),
    {
      fallbackData: fallback,
      debounceMs: 500, // M√°s delay para config
      cacheMs: 10 * 60 * 1000, // 10 minutos de cache
      retryCount: 1 // Solo 1 retry para config
    }
  );
};

// üé£ HOOK ESPEC√çFICO PARA STATS
export const useGymStatsDebounced = () => {
  const fallback = {
    members: 500,
    trainers: 12,
    experience: 8,
    satisfaction: 95
  };

  return useDebounced(
    '/api/gym/statistics',
    () => import('../services/apiService').then(module => module.default.getGymStats()),
    {
      fallbackData: fallback,
      debounceMs: 400,
      cacheMs: 15 * 60 * 1000 // 15 minutos
    }
  );
};

// üé£ HOOK ESPEC√çFICO PARA SERVICIOS
export const useGymServicesDebounced = () => {
  const fallback = [
    {
      id: 1,
      title: 'Entrenamiento Personal',
      description: 'Sesiones 1 a 1 con entrenadores certificados',
      icon: 'Dumbbell'
    },
    {
      id: 2,
      title: 'Clases Grupales',
      description: 'Variedad de clases para todos los niveles',
      icon: 'Users'
    },
    {
      id: 3,
      title: '√Årea de Pesas',
      description: 'Equipos de √∫ltima generaci√≥n',
      icon: 'Target'
    }
  ];

  return useDebounced(
    '/api/gym/services',
    () => import('../services/apiService').then(module => module.default.getGymServices()),
    {
      fallbackData: fallback,
      debounceMs: 350,
      cacheMs: 20 * 60 * 1000 // 20 minutos
    }
  );
};

// üé£ HOOK ESPEC√çFICO PARA PRODUCTOS DESTACADOS
export const useFeaturedProductsDebounced = () => {
  const fallback = [
    {
      id: 1,
      name: 'Prote√≠na Whey Premium',
      price: 250,
      image: '/api/placeholder/300/300',
      category: 'Suplementos'
    },
    {
      id: 2,
      name: 'Camiseta Elite Fitness',
      price: 80,
      image: '/api/placeholder/300/300',
      category: 'Ropa'
    },
    {
      id: 3,
      name: 'Shaker Premium',
      price: 35,
      image: '/api/placeholder/300/300',
      category: 'Accesorios'
    }
  ];

  return useDebounced(
    '/api/gym/featured-products',
    () => import('../services/apiService').then(module => module.default.getFeaturedProducts()),
    {
      fallbackData: fallback,
      debounceMs: 600, // M√°s delay para productos
      cacheMs: 30 * 60 * 1000 // 30 minutos
    }
  );
};

// üé£ HOOK ESPEC√çFICO PARA PLANES
export const useMembershipPlansDebounced = () => {
  const fallback = [
    {
      id: 1,
      name: 'B√°sico',
      price: 200,
      duration: 'mes',
      features: ['Acceso al gimnasio', '√Årea de cardio']
    },
    {
      id: 2,
      name: 'Premium',
      price: 350,
      duration: 'mes',
      popular: true,
      features: ['Todo lo del b√°sico', 'Clases grupales', 'Entrenamiento personal']
    }
  ];

  return useDebounced(
    '/api/gym/plans',
    () => import('../services/apiService').then(module => module.default.getMembershipPlans()),
    {
      fallbackData: fallback,
      debounceMs: 450,
      cacheMs: 25 * 60 * 1000 // 25 minutos
    }
  );
};

// üîß HOOK PARA COORDINADOR STATUS
export const useRequestCoordinatorStatus = () => {
  const [status, setStatus] = useState(requestCoordinator.getStatus());

  useEffect(() => {
    const interval = setInterval(() => {
      setStatus(requestCoordinator.getStatus());
    }, 1000);

    return () => clearInterval(interval);
  }, []);

  return status;
};

export default useDebounced;

// ‚úÖ SISTEMA IMPLEMENTADO:
//
// üö¶ COORDINADOR DE PETICIONES:
// ‚úÖ Evita peticiones duplicadas al mismo endpoint
// ‚úÖ Reutiliza promesas activas
// ‚úÖ Timing controlado entre peticiones
// ‚úÖ Estado global compartido
//
// ‚è∞ DEBOUNCING INTELIGENTE:
// ‚úÖ 200-600ms de delay entre hooks
// ‚úÖ Cancela peticiones anteriores
// ‚úÖ Retry con exponential backoff
// ‚úÖ Cache configurable por hook
//
// üõ°Ô∏è FALLBACKS ROBUSTOS:
// ‚úÖ Datos por defecto para cada hook
// ‚úÖ Manejo silencioso de errores 429
// ‚úÖ Cleanup apropiado al desmontar
// ‚úÖ Estado consistente siempre
//
// üìä HOOKS ESPEC√çFICOS:
// ‚úÖ useGymConfigDebounced - 500ms delay, 10min cache
// ‚úÖ useGymStatsDebounced - 400ms delay, 15min cache  
// ‚úÖ useGymServicesDebounced - 350ms delay, 20min cache
// ‚úÖ useFeaturedProductsDebounced - 600ms delay, 30min cache
// ‚úÖ useMembershipPlansDebounced - 450ms delay, 25min cache
//
// üîß UTILIDADES:
// ‚úÖ useRequestCoordinatorStatus - para debugging
// ‚úÖ refetch manual para cada hook
// ‚úÖ needsRefresh para validar cache
// ‚úÖ Estados claros (loading, loaded, error)